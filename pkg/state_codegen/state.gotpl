{{- /* gotype models.Params */ -}}
// Code generated by state_codegen. DO NOT EDIT.

package scenariostate

import (
"time"
"strings"

uuid "github.com/satori/go.uuid"
)

// MethodsState extendable interface for get and set parameters in methods
type MethodsState interface {
PrepareState()
MergeToResult(params MethodsState) (newState MethodsState) // return merged state without mutation
MergeToState(params MethodsState)                          // merge and mutate state
getters
setters
}

type getters interface {
{{- range $field := .Fields }}
    {{ $field.Name }}() {{ $field.Type }}
{{- end }}
{{- range $field := .Fields }}
    Has{{ $field.Name }}() bool
{{- end }}
}

type setters interface {
{{- range $field := .Fields }}
    Set{{ $field.Name }}({{ $field.Type }})
{{- end }}
}


const (
{{- range $field := .Fields }}
    {{ $field.Name }}Key = "{{ $field.SnakeName }}"
{{- end }}
)

type state struct {
{{- range $field := .Fields }}
    {{ $field.LowerName }} *{{ $field.Type }}
{{- end }}
}

{{- range $field := .Fields }}
    func (s *state) {{$field.Name}}() (val {{$field.Type}}) {
    if s.{{$field.LowerName}} == nil {
    return
    }
    return *s.{{$field.LowerName}}
    }
{{- end }}

{{- range $field := .Fields }}
    func (s *state) Has{{$field.Name}}() bool {
    return s.{{$field.LowerName}} != nil
    }
{{- end }}

{{- range $field := .Fields }}
    func (s *state) Set{{$field.Name}}(param {{$field.Type}}) {
    s.{{$field.LowerName}} = &param
    }
{{- end }}

// NewMethodsState construct new state from raw params
func NewMethodsState(params map[string]interface{}) MethodsState {
st := &state{}
var (
el interface{}
ok bool
)
{{- range $field := .Fields }}
    el, ok = params[{{ $field.Name }}Key]
    if ok {
    {{ if $field.IsDuration}}
        a, err := time.ParseDuration(el.(string) + "h")
        if err != nil {
        panic(err)
        }
    {{else if $field.IsStringSlice}}
        a := strings.Split(el.(string), ",")
    {{else}}a := el.({{ $field.Type }}){{end}}
    st.{{ $field.LowerName }} = &a
    }
{{- end }}
return st
}

// NewEmptyMethodsState construct new empty state
func NewEmptyMethodsState() MethodsState {
return &state{}
}

// MergeToResult merge state and params data to result
func (s *state) MergeToResult(params MethodsState) (newState MethodsState) {
data := *s
if params == nil {
return &data
}

{{- range $field := .Fields }}
    if ok := params.Has{{$field.Name}}(); ok {
    a := params.{{$field.Name}}()
    data.{{$field.LowerName}} = &a
    }
{{- end }}
return &data
}

// MergeToState merge state and params data to state
func (s *state) MergeToState(params MethodsState) {
if params == nil {
return
}
{{- range $field := .Fields }}
    if ok := params.Has{{$field.Name}}(); ok {
    a := params.{{$field.Name}}()
    s.{{$field.LowerName}} = &a
    }
{{- end }}
}

func (s *state) PrepareState() {
{{- range $field := .Fields }}
    {{- if $field.IsString }}
        s.{{$field.LowerName}} = resolveStringValue(*s.{{$field.LowerName}})
    {{- end}}
{{- end }}
}

func resolveStringValue(data string) (value *string) {
switch data {
case "$random":
a := uuid.NewV4().String()
return &a
default:
value = &data
}
return
}
